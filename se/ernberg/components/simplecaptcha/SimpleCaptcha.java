package se.ernberg.components.simplecaptcha;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.HierarchyBoundsListener;
import java.awt.event.HierarchyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;

import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;

import se.ernberg.components.RefreshButton;

/**
 * SuperCaptcha is a captcha component for use together with Java Swing. There
 * are a number of constructors available for customizing the compontent
 * 
 * @author Gustav Ernberg <gustav.ernberg@gmail.com>
 */
public class SimpleCaptcha extends JPanel implements DocumentListener,
		FocusListener, CaptchaStatusListener {
	/**
	 * Generated by Eclipse
	 */
	private static final long serialVersionUID = -6690646366168806898L;
	/**
	 * The image that we're drawing on, keeps track of current word to draw and
	 * which painter to use.
	 */
	private final CaptchaImage captchaImage;
	/**
	 * Used for user-input
	 */
	private final JTextField textfield = new JTextField();
	/**
	 * This is the captchaText that we want the user to write
	 */
	private String captchaText;
	/**
	 * This is the refreshbutton
	 */
	private final RefreshButton refreshButton = new RefreshButton();
	/**
	 * A list of listeners to any changes in the status
	 */
	private final ArrayList<CaptchaStatusListener> captchaStatusListeners = new ArrayList<CaptchaStatusListener>();
	/**
	 * Sets the latestStatus (used to not flood the listeners with events);
	 */
	private boolean latestStatus;
	/**
	 * The painter instance that is responsible for painting the captchaText
	 */
	private CaptchaPainter captchaPainter;
	/**
	 * The generator that is used for generating captcha text strings
	 */
	private CaptchaTextGenerator captchaTextGenerator;

	/**
	 * Calling the constructor without arguments creates an Captcha instance
	 * with options that will suit most users
	 */
	public SimpleCaptcha() {
		this(getDefaultPainter(), getDefaultTextGenerator());
	}

	/**
	 * Allows setting of a CaptchaTextGenerator, the default
	 * CaptchaTextGenerator is used.
	 * 
	 * @param captchaPainter
	 */
	public SimpleCaptcha(CaptchaPainter captchaPainter) {
		this(captchaPainter, getDefaultTextGenerator());
	}

	/**
	 * Allows a custom CaptchaTextGenerator, the default CaptchaPainter is used
	 * 
	 * @param captchaTextGenerator
	 */
	public SimpleCaptcha(CaptchaTextGenerator captchaTextGenerator) {
		this(getDefaultPainter(), captchaTextGenerator);
	}

	/**
	 * Returns the default CaptchaPainter
	 * 
	 * @return
	 */
	private static CaptchaPainter getDefaultPainter() {
		return new ColorCaptchaPainter();
	}

	/**
	 * Returns the default CaptchaTextGenerator
	 * 
	 * @return
	 */
	private static CaptchaTextGenerator getDefaultTextGenerator() {
		return new SimpleCaptchaTextGenerator();
	}

	/**
	 * Calling this constructor allows setting the TextGenerator and
	 * CaptchaPainter
	 * 
	 * @param captchaPainter
	 * @param captchaTextGenerator
	 */
	public SimpleCaptcha(CaptchaPainter captchaPainter,
			CaptchaTextGenerator captchaTextGenerator) {
		this.captchaPainter = captchaPainter;
		this.captchaTextGenerator = captchaTextGenerator;
		captchaText = captchaTextGenerator.generateString();
		captchaImage = new CaptchaImage();

		setLayout(new BoxLayout(this, BoxLayout.LINE_AXIS));
		textfield.setColumns(captchaText.length());

		textfield.getDocument().addDocumentListener(this);
		textfield.addFocusListener(this);
		captchaImage.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseReleased(MouseEvent e) {
				// If one clicks on the captchaImage, set focus to the
				// textfield.
				textfield.requestFocus();
			}
		});

		refreshButton.addActionListener(new ActionListener() {

			@Override
			public void actionPerformed(ActionEvent e) {
				reGenerateCaptchaText();
			}
		});

		add(captchaImage);
		add(textfield);
		add(refreshButton);
		addCaptchaStatusUpdatedListener(this);
	}

	/**
	 * Add a listener that recieves an boolean everytime the users types in the
	 * textfield
	 * 
	 * @param listener
	 */
	public void addCaptchaStatusUpdatedListener(CaptchaStatusListener listener) {
		captchaStatusListeners.add(listener);
	}

	/**
	 * Check whether the new textString is correct, if the status has changed
	 * since last notify all status listeners
	 */
	private void textChanged() {
		boolean isCorrect = isCorrect();
		if (latestStatus != isCorrect) {
			latestStatus = isCorrect;
			notifyStatusListeners(isCorrect);
		}
		captchaImage.forceRegeneratedImage();
	}

	/**
	 * Notifies status listeners that the captcha status is updated
	 * 
	 * @param isCorrect
	 *            if the entered text is correct.
	 */
	private void notifyStatusListeners(boolean isCorrect) {
		for (int i = captchaStatusListeners.size() - 1; i >= 0; i--) {
			captchaStatusListeners.get(i).captchaStatusUpdated(isCorrect);
		}
	}

	/**
	 * Tells if the entered text corresponds to the CAPTCHA
	 * 
	 * @return
	 */
	private boolean isCorrect() {
		return captchaText.equalsIgnoreCase(textfield.getText());
	}

	/**
	 * Call on textChanged() in order to find out if any listeners should be
	 * notified
	 */
	@Override
	public void removeUpdate(DocumentEvent e) {
		textChanged();
	}

	/**
	 * Call on textChanged() in order to find out if any listeners should be
	 * notified
	 */
	@Override
	public void insertUpdate(DocumentEvent e) {
		textChanged();
	}

	/**
	 * Call on textChanged() in order to find out if any listeners should be
	 * notified
	 */
	@Override
	public void changedUpdate(DocumentEvent e) {
		textChanged();
	}

	/**
	 * Always tell listeners the state of the Captcha Component when focus
	 * changes
	 */
	@Override
	public void focusGained(FocusEvent e) {
		notifyStatusListeners(isCorrect());
	}

	/**
	 * Always tell listeners the state of the Captcha Component when focus
	 * changes
	 */
	@Override
	public void focusLost(FocusEvent e) {
		notifyStatusListeners(isCorrect());
	}

	/**
	 * Checks if any options has changed, if so then do repaint and revalidate
	 * 
	 * @param oldObject
	 * @param newObject
	 */
	private void checkIfRepaintIsNeeded(Object oldObject, Object newObject) {
		if (!oldObject.equals(newObject)) {
			revalidate();
			repaint();
		}
	}

	/**
	 * Regenerates the captchaText, useful if the CaptchaTextGenerator or
	 * CaptchaPainter renders unreadable.
	 */
	public void reGenerateCaptchaText() {
		textfield.setText("");
		captchaText = getCaptchaTextGenerator().generateString();
		captchaImage.validate();
		textChanged();
		somethingChanged();
	}

	/**
	 * Is called when something has changed - repaints and revalidates the
	 * component
	 */
	public void somethingChanged() {
		revalidate();
		repaint();
	}

	/**
	 * @return captchaText
	 */
	protected String getCaptchaText() {
		return captchaText;
	}

	/**
	 * This is used to change if the refreshButton should be focusable or not
	 */
	@Override
	public void captchaStatusUpdated(boolean isCorrect) {
		refreshButton.setFocusable(!isCorrect);
	}

	/**
	 * @return {@link CaptchaTextGenerator}
	 */
	public CaptchaTextGenerator getCaptchaTextGenerator() {
		return captchaTextGenerator;
	}

	/**
	 * @return {@link CaptchaPainter}
	 */
	public CaptchaPainter getCaptchaPainter() {
		return captchaPainter;
	}

	/**
	 * Sets the text generator to be used. Please note that if SimpleCaptcha has
	 * generated a text string it will not regenerate one when this method is
	 * called (compare to setCaptchaPainter). If you want to generate a new text
	 * - please use the function reGenerate() in SimpleCaptcha.
	 * 
	 * @param captchaTextGenerator
	 */
	public void setCaptchaTextGenerator(
			CaptchaTextGenerator captchaTextGenerator) {
		checkIfRepaintIsNeeded(this.captchaTextGenerator, captchaTextGenerator);
		this.captchaTextGenerator = captchaTextGenerator;
	}

	/**
	 * The default behaviour of SimpleCaptcha is to repaint the graphics when
	 * this method is called (and the new CaptchaPainter differs from the old
	 * one).
	 * 
	 * @param captchaPainter
	 */
	public void setPainter(CaptchaPainter captchaPainter) {
		checkIfRepaintIsNeeded(this.captchaPainter, captchaPainter);
		this.captchaPainter = captchaPainter;
	}

	/**
	 * Tells if the default refresh button should be shown
	 * 
	 * @return showRefreshButton
	 */
	public void showRefreshButton(boolean showRefreshButton) {
		refreshButton.setVisible(showRefreshButton);
	}

	/**
	 * Tells the CaptchaPainter what to paint and helps Captcha to check the
	 * current size of the captchaImage component
	 * 
	 * @author Gustav Ernberg <gustav.ernberg@gmail.com>
	 */
	private class CaptchaImage extends JPanel implements
			HierarchyBoundsListener {
		/**
		 * Generated by Eclipse
		 */
		private static final long serialVersionUID = 5463117666297420859L;

		/**
		 * Creates a new Captcha Image with a painter associated
		 * 
		 * @param text
		 * @param painter
		 */
		public CaptchaImage() {
			addHierarchyBoundsListener(this);
		}

		/**
		 * Paints the captchaText using the CaptchaPainter
		 */
		@Override
		public void paint(Graphics g) {
			super.paint(g);
			getCaptchaPainter().paint(g, getCaptchaText());
		}

		/**
		 * Let the CaptchImage calculate it's size when neccessary
		 */
		@Override
		public void ancestorResized(HierarchyEvent e) {
			updateSize();
		}
		
		/**
		 * Calculates the size of the paint-area
		 */
		private void updateSize() {
			Dimension dimension = getCaptchaPainter().calculateDimension(
					getGraphics(), getCaptchaText());
			
			setPreferredSize(new Dimension(dimension.width, dimension.height));
			
			revalidate();
			repaint();
		}

		public void forceRegeneratedImage() {
			getCaptchaPainter().forceRegeneratedImage();
			updateSize();
		}

		@Override
		public void ancestorMoved(HierarchyEvent e) {

		}

	}
}
