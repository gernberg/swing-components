package se.ernberg.components.simplecaptcha;

import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.FocusEvent;
import java.awt.event.FocusListener;
import java.awt.event.HierarchyBoundsListener;
import java.awt.event.HierarchyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.util.ArrayList;

import javax.swing.BoxLayout;
import javax.swing.JPanel;
import javax.swing.JTextField;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.text.JTextComponent;

import se.ernberg.components.RefreshButton;

/**
 * SuperCaptcha is a captcha component for use together with Java Swing. There
 * are a number of constructors available for customizing the compontent
 * 
 * @author Gustav Ernberg <gustav.ernberg@gmail.com>
 */
public class SimpleCaptcha extends JPanel implements DocumentListener,
		FocusListener, CaptchaStatusListener {
	/**
	 * Generated by Eclipse
	 */
	private static final long serialVersionUID = -6690646366168806898L;
	/**
	 * The image that we're drawing on, keeps track of current word to draw and
	 * which painter to use.
	 */
	private final CaptchaImage captchaImage;
	/**
	 * Used for user-input
	 */
	private final JTextField textField;
	/**
	 * This is the captchaText that we want the user to write
	 */
	private String captchaText;
	/**
	 * This is the refreshbutton
	 */
	private final RefreshButton refreshButton = new RefreshButton();
	/**
	 * A list of listeners to any changes in the status
	 */
	private final ArrayList<CaptchaStatusListener> captchaStatusListeners = new ArrayList<CaptchaStatusListener>();

	/**
	 * A list of observers that recieves information about when all threads are
	 * done
	 */
	private final ArrayList<CaptchaObserver> captchaObservers = new ArrayList<CaptchaObserver>();
	/**
	 * Sets the latestStatus (used to not flood the listeners with events);
	 */
	private boolean latestStatus;
	/**
	 * The painter instance that is responsible for painting the captchaText
	 */
	private CaptchaPainter captchaPainter;
	/**
	 * The generator that is used for generating captcha text strings
	 */
	private CaptchaTextGenerator captchaTextGenerator;
	/**
	 * The first captcha string-generation sends -1 to observers
	 */
	public static final long CAPTCHA_GENERATED = -1;
	/**
	 * Is used when regenerating strings - may be used by Observers for various
	 * reasons
	 */
	private long lastGenerationID = 0;

	private static String defaultLoadingText = "Loading...";
	
	private String loadingText;
	
	private boolean generatingText = true;
	
	/**
	 * Creating a new SimpleCaptcha, if no TextGenerator and/or CaptchaPainter
	 * is specified the getDefaultPainter() and/or getDefaultTextGenerator() are
	 * used.
	 * 
	 * @see CaptchaPainter
	 * @see CaptchaTextGenerator
	 * @param captchaPainter
	 *            A painter that should paint the captcha text in a somewhat
	 *            readable fashion and present it to the user
	 * @param captchaTextGenerator
	 *            A generator that is responsible for generating the
	 *            text-strings used as captcha
	 * @param loadingText
	 * 			  The text that is shown while {@link CaptchaTextGenerator} is 
	 * 			  generating a captcha string.
	 */
	public SimpleCaptcha() {
		this(getDefaultPainter(), getDefaultTextGenerator());
	}
	public SimpleCaptcha(String loadingText) {
		this(getDefaultPainter(), getDefaultTextGenerator(), loadingText);
	}
	public SimpleCaptcha(CaptchaPainter captchaPainter) {
		this(captchaPainter, getDefaultTextGenerator());
	}

	public SimpleCaptcha(CaptchaTextGenerator captchaTextGenerator) {
		this(getDefaultPainter(), captchaTextGenerator);
	}

	public SimpleCaptcha(CaptchaPainter captchaPainter,
			CaptchaTextGenerator captchaTextGenerator){
		this(captchaPainter, captchaTextGenerator, getDefaultLoadingText());
	}
	public SimpleCaptcha(CaptchaPainter captchaPainter,
			CaptchaTextGenerator captchaTextGenerator, String loadingText){
		this(captchaPainter, captchaTextGenerator, loadingText, new JTextField());
	}
	public SimpleCaptcha(BasicCaptchaPainter captchaPainter,
			CaptchaTextGenerator captchaTextGenerator, JTextField textField) {
		this(captchaPainter, captchaTextGenerator, getDefaultLoadingText(), textField); 
	}
	public SimpleCaptcha(CaptchaPainter captchaPainter,
			CaptchaTextGenerator captchaTextGenerator,
			String loadingText,
			final JTextField textField) {
		this.loadingText = loadingText;
		this.captchaPainter = captchaPainter;
		this.captchaTextGenerator = captchaTextGenerator;
		this.textField = textField;
		captchaImage = new CaptchaImage();

		
		setLayout(new BoxLayout(this, BoxLayout.LINE_AXIS));

		textField.getDocument().addDocumentListener(this);
		textField.addFocusListener(this);
		captchaImage.addMouseListener(new MouseAdapter() {
			@Override
			public void mouseReleased(MouseEvent e) {
				// If one clicks on the captchaImage, set focus to the
				// textfield.
				textField.requestFocus();
			}
		});

		refreshButton.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				textField.setText("");
				generateCaptchaText(lastGenerationID++);
			}
		});

		add(captchaImage);
		add(textField);
		add(refreshButton);
		addCaptchaStatusUpdatedListener(this);
		generateCaptchaText(CAPTCHA_GENERATED);
	}
	/**
	 * Removes the textfield from the captcha component
	 */
	public void removeTextFieldFromCaptchaComponent(){
		remove(textField);
	}
	/**
	 * Returns the default loading text
	 * 
	 * @return String containing loading text
	 */
	protected static  String getDefaultLoadingText() {
		return defaultLoadingText;
	}
	
	/**
	 * Returns the current loading text used.
	 * 
	 * @return String containing current loading text
	 */
	public String getLoadingText() {
		return loadingText;
	}
	/**
	 * Sets the loadingtext to provided string
	 * 
	 * @param loadingText the new String to be used as loading text
	 */
	public void setLoadingText(String loadingText) {
		this.loadingText = loadingText;
	}
	/**
	 * Returns the default CaptchaPainter
	 * 
	 * @return
	 */
	protected static CaptchaPainter getDefaultPainter() {
		return new ColorCaptchaPainter();
	}

	/**
	 * Returns the default CaptchaTextGenerator
	 * 
	 * @return
	 */
	protected static CaptchaTextGenerator getDefaultTextGenerator() {
		return new BasicCaptchaTextGenerator();
	}

	/**
	 * Add a listener that recieves an boolean everytime the users types in the
	 * textfield
	 * 
	 * @param listener
	 */
	public void addCaptchaStatusUpdatedListener(CaptchaStatusListener listener) {
		captchaStatusListeners.add(listener);
	}

	/**
	 * Removes a listener that recieves an boolean everytime the users types in
	 * the textfield
	 * 
	 * @param listener
	 */
	public void removeCaptchaStatusUpdatedListener(
			CaptchaStatusListener listener) {
		captchaStatusListeners.remove(listener);
	}

	/**
	 * Adds an observer that recieves notifications when a new string is
	 * generated.
	 * 
	 * @param observer
	 */
	public void addCaptchaObserver(CaptchaObserver observer) {
		captchaObservers.add(observer);

	}

	/**
	 * Removes an observer
	 * 
	 * @param observer
	 */
	public void removeCaptchObserver(CaptchaObserver observer) {
		captchaObservers.remove(observer);
	}

	/**
	 * Check whether the new textString is correct, if the status has changed
	 * since last notify all status listeners
	 */
	private void textChanged() {
		boolean isCorrect = isCorrect();
		if (latestStatus != isCorrect) {
			latestStatus = isCorrect;
			notifyStatusListeners(isCorrect);
		}
	}

	/**
	 * Notifies status listeners that the captcha status is updated
	 * 
	 * @param isCorrect
	 *            if the entered text is correct.
	 */
	private void notifyStatusListeners(boolean isCorrect) {
		for (int i = captchaStatusListeners.size() - 1; i >= 0; i--) {
			captchaStatusListeners.get(i).statusUpdated(isCorrect);
		}
	}

	/**
	 * Notifies the 
	 * @param textGenerationID
	 */
	private void notifyTextGenerationObservers(long textGenerationID) {
		for (int i = captchaObservers.size() - 1; i >= 0; i--) {
			captchaObservers.get(i).textGenerationComplete(textGenerationID);
		}
	}

	/**
	 * Tells if the entered text corresponds to the CAPTCHA
	 * 
	 * @return
	 */
	private boolean isCorrect() {
		if(captchaText==null)
			return false;
		return captchaText.equalsIgnoreCase(textField.getText());
	}

	/**
	 * Call on textChanged() in order to find out if any listeners should be
	 * notified
	 */
	@Override
	public void removeUpdate(DocumentEvent e) {
		textChanged();
	}

	/**
	 * Call on textChanged() in order to find out if any listeners should be
	 * notified
	 */
	@Override
	public void insertUpdate(DocumentEvent e) {
		textChanged();
	}

	/**
	 * Call on textChanged() in order to find out if any listeners should be
	 * notified
	 */
	@Override
	public void changedUpdate(DocumentEvent e) {
		textChanged();
	}

	/**
	 * Always tell listeners the state of the Captcha Component when focus
	 * changes
	 */
	@Override
	public void focusGained(FocusEvent e) {
		notifyStatusListeners(isCorrect());
	}

	/**
	 * Always tell listeners the state of the Captcha Component when focus
	 * changes
	 */
	@Override
	public void focusLost(FocusEvent e) {
		notifyStatusListeners(isCorrect());
	}

	/**
	 * Checks if any options has changed, if so then do repaint and revalidate
	 * 
	 * @param oldObject
	 * @param newObject
	 */
	private void repaintIfDifferent(Object oldObject, Object newObject) {
		if (!oldObject.equals(newObject)) {
			revalidate();
			repaint();
		}
	}

	/**
	 * Is called when something has changed - repaints and revalidates the
	 * component
	 */
	public void updateGraphics() {
		captchaImage.forceRegeneratedImage();
		revalidate();
		repaint();
	}

	/**
	 * Returns the captcha text.
	 * Should never be called if isGenerating is true.
	 * 
	 * @return captchaText
	 */
	protected String getCaptchaText(){
		return captchaText;
	}

	/**
	 * This is used to change if the refreshButton should be focusable or not
	 */
	@Override
	public void statusUpdated(boolean isCorrect) {
		refreshButton.setFocusable(!isCorrect);
	}

	/**
	 * @return {@link CaptchaTextGenerator}
	 */
	public CaptchaTextGenerator getCaptchaTextGenerator() {
		return captchaTextGenerator;
	}

	/**
	 * @return {@link CaptchaPainter}
	 */
	public CaptchaPainter getCaptchaPainter() {
		return captchaPainter;
	}

	/**
	 * Returns the last generation id, used by Observers (increase by one every
	 * time refresh-button is clicked.)
	 * 
	 * @return
	 */
	public long getLastGenerationID() {
		return lastGenerationID;
	}

	/**
	 * Sets the text generator to be used. Please note that if SimpleCaptcha has
	 * generated a text string it will not regenerate one when this method is
	 * called (compare to setCaptchaPainter). If you want to generate a new text
	 * - please use the function reGenerate() in SimpleCaptcha.
	 * 
	 * @param captchaTextGenerator
	 */
	public void setTextGenerator(
			CaptchaTextGenerator captchaTextGenerator) {
		this.captchaTextGenerator = captchaTextGenerator;
	}

	/**
	 * The default behaviour of SimpleCaptcha is to repaint the graphics when
	 * this method is called (and the new CaptchaPainter differs from the old
	 * one).
	 * 
	 * @param captchaPainter
	 */
	public void setPainter(CaptchaPainter captchaPainter) {
		repaintIfDifferent(this.captchaPainter, captchaPainter);
		this.captchaPainter = captchaPainter;
	}

	/**
	 * Tells if the default refresh button should be shown
	 * 
	 * @return showRefreshButton
	 */
	public void showRefreshButton(boolean showRefreshButton) {
		refreshButton.setVisible(showRefreshButton);
	}
	private void startGeneratingText(){
		generatingText = true;
		updateGraphics();
	}
	private void doneGeneratingText(){
		generatingText = false;
		updateGraphics();
	}
	private boolean isGeneratingText(){
		return generatingText;
	}
	/**
	 * Generates the captchaText, useful if the CaptchaTextGenerator or
	 * CaptchaPainter renders unreadable.
	 */
	public void generateCaptchaText(long textGenerationID) {
		(new CaptchaTextGenerationThread(textGenerationID)).start();
	}
	/**
	 * A thread that generates a new Captcha string and updates the component 
	 * and notifies observers. 
	 *
	 * @author Gustav Ernberg <gustav.ernberg@gmail.com>
	 */
	private class CaptchaTextGenerationThread extends Thread {
		private final long textGenerationID;

		private CaptchaTextGenerationThread(long textGenerationID) {
			
			this.textGenerationID = textGenerationID;
		}

		@Override
		public void run() {
			startGeneratingText();
			captchaText = captchaTextGenerator.generateString();
			doneGeneratingText();
			textField.setColumns(captchaText.length());
			captchaImage.validate();
			textChanged();
			updateGraphics();
			notifyTextGenerationObservers(textGenerationID);
		}

	}
	/**
	 * Tells the CaptchaPainter what to paint and helps Captcha to check the
	 * current size of the captchaImage component
	 * 
	 * @author Gustav Ernberg <gustav.ernberg@gmail.com>
	 */
	private class CaptchaImage extends JPanel implements
			HierarchyBoundsListener {
		/**
		 * Used to keep track of "real"-changes in height / width of this
		 * component (in order to avoid unneccesary regeneration of
		 * captcha-images)
		 */
		int oldWidth, oldHeight;
		/**
		 * Generated by Eclipse
		 */
		private static final long serialVersionUID = 5463117666297420859L;

		/**
		 * Creates a new Captcha Image with a painter associated
		 * 
		 * @param text
		 * @param painter
		 */
		public CaptchaImage() {
			addHierarchyBoundsListener(this);
		}

		/**
		 * Paints the captchaText using the CaptchaPainter on the graphics
		 * 
		 * @param g
		 */
		@Override
		public void paint(Graphics g) {
			super.paint(g);
			Dimension d = new Dimension(getWidth(), getHeight());
			if(isGeneratingText()){
				getCaptchaPainter().paintLoadingGraphics(g, getLoadingText(), d);
			}else{
				getCaptchaPainter().paint(g, getCaptchaText(), d);
			}
		}

		/**
		 * Let the Captcha regenerate image and calculate size when neccessary
		 * (when width or height has changed)
		 */
		@Override
		public void ancestorResized(HierarchyEvent e) {
			if (oldWidth != getWidth() || oldHeight != getHeight()) {
				oldWidth = getWidth();
				oldHeight = getHeight();
				forceRegeneratedImage();
			}
		}

		/**
		 * Updates the size
		 */
		private void updateSize() {
			revalidate();
			repaint();
		}

		/**
		 * Calculates the preferred size of the component
		 * 
		 * @return preferred dimensions of captcha image
		 */
		@Override
		public Dimension getPreferredSize() {
			if(isGeneratingText()){
				return getCaptchaPainter().calculateLoadingDimension(getGraphics(),
						getLoadingText());
			}else{
				return getCaptchaPainter().calculateDimension(getGraphics(),
						getCaptchaText());	
			}
		}

		/**
		 * Calculates the minimum size of the component in order to make it work
		 * (if it's resized too small it's possible that text will render
		 * unreadable)
		 * 
		 * @return minimum size
		 */
		@Override
		public Dimension getMinimumSize() {
			return getPreferredSize();
		}

		/**
		 * Forces the image to be regenerated and updates the size.
		 */
		public void forceRegeneratedImage() {
			getCaptchaPainter().forceRegeneratedImage();
			updateSize();
		}

		@Override
		public void ancestorMoved(HierarchyEvent e) {

		}
	}
}
